##################################################
## Project: BRB-seq
## Script purpose: Generating Figure 3, Panel G
## Date: 2022 Oct 05
## Author: Vincent Gardeux (vincent.gardeux@epfl.ch)
##################################################

## Change working directory
setwd("/data/gardeux/BRBseq/")

# Loading libraries
suppressPackageStartupMessages(require(edgeR)) # for cpm calculation
suppressPackageStartupMessages(require(ggplot2))
suppressPackageStartupMessages(require(scales)) # for log_trans function
suppressPackageStartupMessages(require(Metrics)) # for rmse function
suppressPackageStartupMessages(require(MASS)) # for dose.p function

## Functions
# Custom name x Axis
labelling <- function(){
  function(x) {
    #return(paste0(round(x / 1000, 1), "M"))
    return(paste0(round(x / 1000, 1)))
  }
}

# Log axis
base_breaks <- function(n = 10){
  function(x) {
    axisTicks(log10(range(x, na.rm = TRUE)), log = TRUE, n = n)
  }
}

# Generate Downsampled names
downsample.names <- function(name, cnt, nreps){
  res = c()
  for(n in 1:nreps){
    res = c(res, paste0(name,".DS_",cnt,"_",n))
  }
  res
}

# Optimized interpolation of sequencing depth vs detection
fitFunction <- function(power, data.tmp){
  toPredict = data.tmp$down^(1/power)
  fit = glm(data.tmp$detection~toPredict, family="quasibinomial")
  detection.prediction <- predict(fit, list(down = sort(data.tmp$down)), type="response")
  rmse(detection.prediction, data.tmp$detection)
}

## Gold Standard #1: Truseq paired-end all reads
## Load Truseq Paired-end dataset, to use as Gold Standard
data.raw = read.table("data/truseq.count.matrix.PE.txt", sep="\t", header = T, row.names=1, check.names = F)
# Remove extra rows generated by HTseq-count
remove = c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")
data.raw = data.raw[!(rownames(data.raw) %in% remove),]
# Remove genes that are not expressed in any sample
data.raw = data.raw[rowSums(data.raw) != 0,]

# CPM Calculation (using edgeR package)
data.cpm <- DGEList(counts=data.raw)
data.cpm <- calcNormFactors(data.cpm)
data.cpm <- as.data.frame(cpm(data.cpm))
# Separate by time point (here I keep only T0)
data.cpm.t0 <- rowSums(data.cpm[,c("T0A", "T0B")])
data.cpm.t0 = as.data.frame(data.cpm.t0[data.cpm.t0 != 0])

## Truseq downsampled (deep = many downsampling depth)
data.raw = read.table("data/truseq.count.matrix.DS.deep.txt", sep="\t", header = T, row.names=1, check.names = F)
# Remove extra rows generated by HTseq-count
remove = c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")
data.raw = data.raw[!(rownames(data.raw) %in% remove),]

## Expressed genes
data.boxplot = data.frame(down=-1, type="T0", strat=100, max = 0, detect.reads=0)
for(i in c(100,500,1000,2000,3000,4000,5000,6000,7000,8000,9000,10000,20000,30000,40000,45000)){
  for(st in c(100, 50, 10, 5, 4, 3, 2, 1, 0.5, 0.1, 0)){
    cpm.t0 = rownames(data.cpm.t0)[data.cpm.t0 >= st]
    data.raw.subset = data.raw[cpm.t0,c(downsample.names("T0A",i,5), downsample.names("T0B",i,5))]
    data.boxplot.tmp = data.frame(down = i, type="TruSeq", strat=st, max=length(cpm.t0), detect.reads=mean(colSums(data.raw.subset > 0)))
    data.boxplot = rbind(data.boxplot, data.boxplot.tmp)
  }
}
# Remove fake first line
data.boxplot = data.boxplot[data.boxplot$down != -1,]

## Gold Standard #2: BRB-seq all reads
# Load dataset
data.raw = read.table("data/brbseq.count.matrix.txt", sep="\t", header = T, row.names=1, check.names = F)
# Remove extra rows generated by BRBseq-Tools
remove = c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")
data.raw = data.raw[!(rownames(data.raw) %in% remove),]
# Remove genes that are not expressed in any sample
data.raw = data.raw[rowSums(data.raw) != 0,]
# CPM Calculation (using edgeR package)
data.cpm <- DGEList(counts=data.raw)
data.cpm <- calcNormFactors(data.cpm)
data.cpm <- as.data.frame(cpm(data.cpm))
# Separate by time point (here I keep only T0)
data.cpm.t0 <- rowSums(data.cpm[,c("T0A", "T0B")])
data.cpm.t0 = as.data.frame(data.cpm.t0[data.cpm.t0 != 0])

## BRB-seq downsampled (deep = many downsampling depth)
######
## Important note: At the time I prepare these scripts (5 years post analysis), I cannot find the last version of the downsampled BRB-seq data, which was containing the following downsampling depth: c(100,500,1000,2000,3000,4000,5000,6000,7000,8000,9000,10000,20000,30000)
##                 This version I'm using here has much less granularity (only c(100,500,1000,1500,2000,2500,2900)). So the end results will be slightly different with the publication.
######
data.raw = read.table("data/brbseq.count.matrix.DS.deep.txt", sep="\t", header = T, row.names=1, check.names = F)
# Remove extra rows generated by BRBseq-Tools
remove = c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")
data.raw = data.raw[!(rownames(data.raw) %in% remove),]

## Expressed genes
for(i in c(100,500,1000,1500,2000,2500,2900)){
  for(st in c(100, 50, 10, 5, 4, 3, 2, 1, 0.5, 0.1, 0)){
    # Here, I plot the curve only for t0
    cpm.t0 = rownames(data.cpm.t0)[data.cpm.t0 >= st]
    data.raw.subset = data.raw[cpm.t0,c(downsample.names("DA4_T0A",i,5), downsample.names("DA4_T0B",i,5))]
    data.boxplot.tmp = data.frame(down = i, type="BRB-seq", strat=st, max=length(cpm.t0), detect.reads=mean(colSums(data.raw.subset > 0)))
    data.boxplot = rbind(data.boxplot, data.boxplot.tmp)
  }
}

## Compute curve detection probabilities
data.final = data.frame(type="T", cpm=st, depth=-1)

## I plot the intermediary curves, for the record
pdf("Figure3G_supp_curve.detection.prob.cpm.pdf", width = 22, height = 8)
par(mfrow=c(2,9))
for(t in c("TruSeq", "BRB-seq")){
  for(st in c(10, 5, 4, 3, 2, 1, 0.5, 0.1, 0)) {
    data.tmp = subset(data.boxplot, strat == st & type == t)
    data.tmp$detection = data.tmp$detect.reads / data.tmp$max
    power = optimize(fitFunction, data.tmp, interval=c(0,1000000))$minimum
    plot(data.tmp$down, data.tmp$detection)
    toPredict = data.tmp$down^(1/power)
    fit = glm(data.tmp$detection~toPredict, family="quasibinomial")
    detection.prediction <- predict(fit, list(down = sort(data.tmp$down)), type="response")
    lines(sort(data.tmp$down), detection.prediction, lty=1, lwd=2, col="blue")
    required.depth = dose.p(fit, p=0.95)[[1]]^power
    if(is.nan(required.depth)) required.depth = 0
    abline(v = required.depth, lty=2)
    abline(h = 0.95, lty=2)
    title(paste0("CPM > " , st, "\nReq. depth = ", required.depth))
    data.final.tmp = data.frame(type=t, cpm=st, depth=required.depth)
    data.final = rbind(data.final, data.final.tmp)
  }
}
dev.off()

# Remove initial fake row
data.final = data.final[data.final$depth != -1,]

# Make type as factor
data.final$type <- factor(data.final$type, levels = c("TruSeq", "BRB-seq"))

# Plot final curve
p <- ggplot(data.final, aes(depth, cpm)) + coord_cartesian() + scale_x_continuous(labels=labelling(), trans = log_trans(), breaks = base_breaks()) + scale_y_continuous() + geom_line(aes(color=type), size = 1, show.legend = FALSE)
p <- p + theme(legend.position = "right", legend.justification = "bottom", axis.line = element_line(colour = "black"), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.border = element_blank(), panel.background = element_blank()) 
p <- p + labs(x="Sequencing depth, M of reads", y="Detected CPM threshold") + scale_color_discrete(name = "", type = c("#4E597F", "#E9C55A"))
# Add a rectangle for the color legend
p <- p + geom_rect(aes(xmin = 0, xmax = 0, ymin = 0, ymax = 0, color = type), size = 1, fill = "white") 
suppressWarnings(ggsave("Figure3G.pdf", plot = p, width = 7, height = 5))

